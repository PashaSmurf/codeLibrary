Методы у примитивов

Примитив
- Это – значение «примитивного» типа.
- Есть 6 примитивных типов: string, number, boolean, symbol, null и undefined.

Объект
- Может хранить множество значений как свойства.
- Объявляется при помощи фигурных скобок {}, например: {name: "Рома", age: 30}. 
В JavaScript есть и другие виды объектов: например, функции тоже являются объектами.

Каждый примитив имеет свой собственный «объект-обёртку», которые называются: 
String, Number, Boolean и Symbol. Таким образом, они имеют разный набор методов.

Конструкторы String/Number/Boolean предназначены только для внутреннего пользования
Некоторые языки, такие как Java, позволяют явное создание «объектов-обёрток» 
для примитивов при помощи такого синтаксиса как new Number(1) или new Boolean(false).
В JavaScript, это тоже возможно по историческим причинам, но очень не рекомендуется. 
В некоторых местах последствия могут быть катастрофическими.

С другой стороны, использование функций String/Number/Boolean без оператора new – вполне разумно и полезно. 
Они превращают значение в соответствующий примитивный тип: в строку, в число, в булевый тип.

Особенные примитивы null и undefined являются исключениями. У них нет соответствующих 
«объектов-обёрток», и они не имеют никаких методов. В некотором смысле, они «самые примитивные».

Числа
Способы записи числа

let billion = 1000000000;
let billion = 1e9;

let ms = 0.000001;
let ms = 1e-6;

Шестнадцатеричные, двоичные и восьмеричные числа
alert( 0xff ); // 255-16
let a = 0b11111111; //255-2
let b = 0o377; //255-8

toString(base)
Метод num.toString(base) возвращает строковое представление числа num в системе счисления base.
alert( num.toString(16) );  // ff
alert( 123456..toString(36) ); // 2n9c (если бы применяем toString на "голом" числе

Округление
	Math.floor	Math.ceil	Math.round	Math.trunc
3.1		3		4		3		3
3.6		3		4		4		3
-1.1		-2		-1		-1		-1
-1.6		-2		-1		-2		-1

Проверка: isFinite и isNaN

Значение NaN уникально тем, что оно не является равным ни чему другому, даже самому себе.
isNaN(value) преобразует значение в число и проверяет является ли оно NaN
alert( isNaN(NaN) ); // true
alert( isNaN("str") ); // true
alert( isNaN("123") ); // false

parseInt и parseFloat
alert( +"100px"); //NaN
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5
Функции parseInt/parseFloat вернут NaN, если не смогли прочитать ни одну цифру
alert( parseInt('a123') ); // NaN
Функция parseInt() имеет необязательный второй параметр. Он определяет систему счисления, 
таким образом parseInt может также читать строки с шестнадцатеричными числами, двоичными числами и т.д.


Строки
Строку можно создать с помощью одинарных, двойных либо обратных кавычек
Одинарные и двойные кавычки работают, по сути, одинаково, а если использовать обратные кавычки, 
то в такую строку мы сможем вставлять произвольные выражения, обернув их в ${…}

Длина строки
alert( `My\n`.length ); // 3

Доступ к символам
let str = `Hello`;
// получаем первый символ
alert( str[0] ); // H

Также можно перебрать строку посимвольно, используя for..of:
for (let char of "Hello") {
  alert(char); // H,e,l,l,o (char — сначала "H", потом "e", потом "l" и т. д.)
}

Строки неизменяемы
let str = 'Hi';
str[0] = 'h'; // ошибка
alert( str[0] ); // не работает

Изменение регистра
Методы toLowerCase() и toUpperCase() меняют регистр символов:
alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'.toLowerCase() ); // interface

Поиск подстроки
str.indexOf(substr, pos);
Он ищет подстроку substr в строке str, начиная с позиции pos, и возвращает позицию, 
на которой располагается совпадение, либо -1 при отсутствии совпадений.

Более современный метод str.includes(substr, pos) возвращает true, 
если в строке str есть подстрока substr, либо false, если нет.

Методы str.startsWith и str.endsWith проверяют, соответственно, 
начинается ли и заканчивается ли строка определённой строкой:
alert( "Widget".startsWith("Wid") ); // true, "Wid" — начало "Widget"
alert( "Widget".endsWith("get") ); // true, "get" — окончание "Widget"

Получение подстроки
str.slice(start [, end])
Возвращает часть строки от start до (не включая) end.

str.substr(start [, length])
Возвращает часть строки от start длины length.
В противоположность предыдущим методам, этот позволяет указать длину вместо конечной позиции